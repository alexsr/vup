//
// Alexander Scheid-Rehder
// alexanderb@scheid-rehder.de
// https://www.alexsr.de
// https://github.com/alexsr
//

#include <vup/Core/demo_utils.h>
#include <vup/Core/cpp_utils.h>
#include <vup/Simulation/particle_utils.h>
#include <vup/Rendering/Trackball_camera.h>
#include <vup/Shader/V_F_shader.h>
#include <vup/Shader/V_G_F_shader.h>
#include <vup/GPU_Storage/Instanced_VAO.h>
#include <vup/GPU_Storage/VAO.h>
#include <vup/Utility/OpenGL_debug_logger.h>
#include <vup/Shader/Compute_pipeline.h>
#include <vup/Simulation/Acceleration_structure.h>
#include <vup/Core/Gui_window.h>
#include "vup/Simulation/simulation_utils.h"

int main() {
    vup::init_glfw();
    const int width = 800;
    const int height = 600;
    vup::Gui_window curr_window(width, height, "DFSPH heat transfer demo", true);
    vup::OpenGL_debug_logger gl_debug_logger;
    gl_debug_logger.disable_messages(GL_DONT_CARE, GL_DONT_CARE, GL_DEBUG_SEVERITY_NOTIFICATION);
    vup::Trackball_camera cam(width, height);
    vup::init_demo_OpenGL_params();
    vup::Cube bounds_cube(2.0f, 2.0f, 2.0f);
    vup::VAO bounds_vao(bounds_cube);
    vup::V_F_shader box_renderer("../../src/shader/rendering/mvp_ubo.vert",
                                 "../../src/shader/rendering/minimal.frag");
    glm::mat4 model(1.0f);
    glm::mat4 bb_model(1.0f);
    vup::MVP mats{glm::mat4(1.0f), cam.get_view(), cam.get_projection()};
    float smoothing_length = 0.1;
    float mass_scaling = 2.0f / 3.0f;
    float h = smoothing_length * mass_scaling;

    vup::Simulation_timer sim_timer;
    sim_timer.time_scaling = 1.0;
    sim_timer.dt = 0.00005;
    float density_rest = 1000.0f; // density at 4C
    float visc_const = 0.02f;
    float tension_const = 0.0f;
    float temperature = 0.0f;
    float max_error = 0.1f;
    float cg_max_error = 0.01f;
    float density_eta = density_rest * max_error * 0.01;
    float div_eta = density_eta * 1.0f / sim_timer.dt;
    int max_iterations = 100;
    float heat_source_temp = 100.0f;
    vup::DFSPH_heat_demo_constants demo_consts(smoothing_length, mass_scaling, sim_timer.dt);
    auto particle_data = vup::create_DFSPH_heat_particles(demo_consts.r, h, -0.7f, 0.7f,
                                                          density_rest, visc_const, temperature, 100.0f);
    auto instances = static_cast<int>(particle_data.size());
    for (auto i = 0; i < static_cast<float>(instances) * 0.5f; i++) {
        particle_data.at(i).temperature = 373.0f;
    }
    const vup::Sphere sphere(demo_consts.r);
    vup::Instanced_VAO particle_spheres(sphere);
    vup::SSBO particles(particle_data, 0, vup::gl::storage::dynamic | vup::gl::storage::read | vup::gl::storage::write);
    vup::SSBO demo_consts_buffer(demo_consts, 1);
    int neighbor_amount = 40;
    vup::Empty_SSBO neighbors_ssbo(neighbor_amount * instances * sizeof(int), 2);
    vup::Empty_SSBO neighbor_count_ssbo(instances * sizeof(int), 3);

    vup::Cube_uniform_grid_params grid_params(3.0f, demo_consts.h, neighbor_amount);
    vup::Empty_SSBO uniform_grid_ssbo(grid_params.grid_capacity * sizeof(int), 4);
    vup::Empty_SSBO uniform_grid_cell_counter_ssbo(grid_params.total_cell_count * sizeof(int), 5);
    vup::SSBO grid_params_buffer(grid_params, 6);

    vup::Empty_SSBO scalar_buffer(instances * sizeof(float), 7, vup::gl::storage::read);
    vup::Empty_SSBO second_scalar_buffer(instances * sizeof(float), 8, vup::gl::storage::read);

    const std::vector<vup::Shader_define> sph_defines = {
        {"N", std::to_string(instances)},
        {"NEIGHBOR_AMOUNT", std::to_string(neighbor_amount)},
        {"NEIGHBOR_ARRAY_SIZE", std::to_string(instances * neighbor_amount)},
        {"GRID_CAPACITY", std::to_string(grid_params.grid_capacity)},
        {"CELL_COUNT", std::to_string(grid_params.total_cell_count)}
    };

    vup::UBO mvp(mats, 0);

    vup::V_F_shader particle_renderer("../../src/shader/particles/dfsph/instanced_iisph.vert",
                                      "../../src/shader/particles/particles.frag", sph_defines);

    vup::Compute_shader reset_grid("../../src/shader/data_structures/reset_grid.comp", sph_defines);

    vup::Compute_pipeline compute_densities({
                                                "populate_grid.comp", "find_neighbors_in_grid.comp",
                                                "calc_density_alpha.comp"
                                            },
                                            sph_defines,
                                            "../../src/shader/particles/dfsph/");

    vup::Compute_shader predict_velocity("../../src/shader/particles/dfsph/calc_non_pressure_accel.comp", sph_defines);

    vup::Compute_shader predict_density("../../src/shader/particles/dfsph/predict_density.comp", sph_defines);

    vup::Compute_pipeline correct_density_error({
                                                    "predict_density.comp",
                                                    "adapt_vel_density.comp"
                                                },
                                                sph_defines,
                                                "../../src/shader/particles/dfsph/");

    vup::Compute_shader update_positions("../../src/shader/particles/dfsph/update_positions.comp",
                                         sph_defines);

    vup::Compute_pipeline correct_divergence_error({
                                                       "predict_density_div.comp",
                                                       "adapt_vel_div.comp"
                                                   },
                                                   sph_defines,
                                                   "../../src/shader/particles/dfsph/");

    vup::Compute_pipeline initiate_viscosity_solver({
                                                        "jacobi_preconditioner.comp",
                                                        "calc_initial_residual.comp"
                                                    },
                                                    sph_defines,
                                                    "../../src/shader/particles/dfsph/viscosity/");

    const vup::Shader_define initial_precond{"INITIAL_SEARCH", ""};
    vup::Compute_shader initial_precond_solve("../../src/shader/particles/dfsph/viscosity/precond_solve.comp",
                                              vup::cpp::append_to_vector(sph_defines, initial_precond));

    vup::Compute_shader compute_Ap("../../src/shader/particles/dfsph/viscosity/compute_Ap.comp",
                                   sph_defines);

    vup::Compute_pipeline update_solution({"update_solution.comp", "calc_residual_squared.comp"}, sph_defines,
                                          "../../src/shader/particles/dfsph/viscosity/");

    vup::Compute_shader solve_for_z("../../src/shader/particles/dfsph/viscosity/precond_solve.comp",
                                    sph_defines);

    vup::Compute_shader update_search_dir("../../src/shader/particles/dfsph/viscosity/update_search_direction.comp",
                                          sph_defines);

    vup::Compute_shader reduce_scalar("../../src/shader/particles/reduce_scalar.comp",
                                      {{"X", "1024"}, {"ID", "7"}, {"N", std::to_string(instances)}});
    vup::Compute_shader reduce_second_scalar("../../src/shader/particles/reduce_scalar.comp",
                                             {{"X", "1024"}, {"ID", "8"}, {"N", std::to_string(instances)}});
    vup::Compute_shader max_scalar("../../src/shader/particles/max_scalar.comp",
                                   {{"X", "1024"}, {"N", std::to_string(instances)}});
    const auto max_blocks = static_cast<int>(glm::ceil(static_cast<float>(instances)
                                                       / reduce_scalar.get_workgroup_size_x()));
    reduce_scalar.update_uniform("max_index", instances);
    reduce_scalar.update_uniform("max_blocks", max_blocks);
    max_scalar.update_uniform("max_index", instances);
    max_scalar.update_uniform("max_blocks", max_blocks);
    std::vector<float> new_scalar(max_blocks);

    //bb_model = rotate(bb_model, delta * 0.1f, glm::vec3(0.3, 0.3f, 0.3f));

    const auto reload_shaders = [&]() {
        particle_renderer.reload();
        box_renderer.reload();
        compute_densities.reload();
        predict_velocity.reload();
        predict_velocity.reload();
        correct_density_error.reload();
        update_positions.reload();
        correct_divergence_error.reload();
        reset_grid.reload();
        reduce_scalar.reload();
        max_scalar.reload();
    };

    bool pause_sim = false;
    vup::Time_counter fps_counter;
    vup::Time_counter ips_counter;
    const auto loop = [&]() {
        ImGui::Begin("My First Tool");
        ImGui::TextWrapped("Simulation average %.3f ms/iteration (%.1f Iterations per second)",
                           1000.0f / ips_counter.average_aps(), ips_counter.average_aps());
        ImGui::TextWrapped("Simulation current %.3f ms/iteration (%.1f Iterations per second)",
                           1000.0f / ips_counter.one_second_average, ips_counter.one_second_average);
        ImGui::TextWrapped("Rendering average %.3f ms/frame (%.1f FPS)",
                           1000.0f / fps_counter.average_aps(), fps_counter.average_aps());
        if (ImGui::DragFloat("Time scaling", &sim_timer.time_scaling, 0.01f, 0.01f, 10.0f)
            || ImGui::DragFloat("Iteration time", &sim_timer.dt, 0.0001f, 0.0001f, 1.0f, "%.4f")) {
            demo_consts = vup::DFSPH_heat_demo_constants(smoothing_length, mass_scaling, sim_timer.dt);
            demo_consts_buffer.update_data(demo_consts);
        }
        if (ImGui::SliderFloat("Smoothing length", &smoothing_length, 0.0f, 1.0f)) {
            demo_consts = vup::DFSPH_heat_demo_constants(smoothing_length, mass_scaling, sim_timer.dt);
            demo_consts_buffer.update_data(demo_consts);
        }
        if (ImGui::SliderFloat("Viscosity", &visc_const, 0.0f, 1.0f)) {
        }
        if (ImGui::SliderFloat("Surface Tension", &tension_const, 0.0f, 10.0f)) {
            predict_velocity.update_uniform("tension_const", tension_const);
        }
        //        if (ImGui::SliderFloat("Heat source temperature", &heat_source_temp, -1000.0f, 1000.0f)) {
        //            demo_consts.temperature = heat_source_temp + 273.15f;
        //            demo_consts_buffer.update_data(demo_consts);
        //        }
        if (pause_sim && ImGui::Button("Unpause simulation")) {
            pause_sim = false;
        }
        if (ImGui::Button("Reload scene")) {
            reload_shaders();
            particles.update_data(particle_data);
            demo_consts_buffer.update_data(demo_consts);
            predict_velocity.update_uniform("tension_const", tension_const);
            reduce_scalar.update_uniform("max_index", instances);
            reduce_scalar.update_uniform("max_blocks", max_blocks);
            max_scalar.update_uniform("max_index", instances);
            max_scalar.update_uniform("max_blocks", max_blocks);
        }
        ImGui::End();
        if (!pause_sim) {
            //while (sim_timer.is_iteration_due()) {

                reset_grid.run_with_barrier(grid_params.total_cell_count);
                compute_densities.run_with_barrier(instances);
                // divergence error correction
                int iteration = 0;
                float density_div_avg = 0;
                while ((density_div_avg > div_eta || iteration < 1) && iteration < max_iterations) {
                    correct_divergence_error.run_with_barrier(instances);
                    reduce_scalar.run_with_barrier(instances);
                    scalar_buffer.get_data(new_scalar);
                    for (auto v : new_scalar) {
                        density_div_avg += v;
                    }
                    density_div_avg /= instances;
                    iteration++;
                }

                // implicit viscosity solver
                // initiate conjugate gradient solver
                initiate_viscosity_solver.run_with_barrier(instances);
                float residual_norm2 = 0;
                reduce_scalar.run_with_barrier(instances);
                scalar_buffer.get_data(new_scalar);
                for (auto v : new_scalar) {
                    residual_norm2 += v;
                }
                float rhs_norm2 = 0;
                reduce_second_scalar.run_with_barrier(instances);
                second_scalar_buffer.get_data(new_scalar);
                for (auto v : new_scalar) {
                    rhs_norm2 += v;
                }
                float cg_threshold = cg_max_error * cg_max_error * rhs_norm2;
                if (rhs_norm2 != 0 && residual_norm2 >= cg_threshold) {
                    float abs_r = 0.0f;
                    initial_precond_solve.run_with_barrier(instances);
                    reduce_scalar.run_with_barrier(instances);
                    scalar_buffer.get_data(new_scalar);
                    for (auto v : new_scalar) {
                        abs_r += v;
                    }
                    float abs_r_old = 0.0f;
                    for (int it = 0; it < max_iterations; it++) {
                        float alpha_denom = 0.0f;
                        compute_Ap.run_with_barrier(instances);
                        reduce_scalar.run_with_barrier(instances);
                        scalar_buffer.get_data(new_scalar);
                        for (auto v : new_scalar) {
                            alpha_denom += v;
                        }
                        float alpha = abs_r / alpha_denom;
                        update_solution.update_uniform("alpha", alpha);
                        update_solution.run_with_barrier(instances);
                        residual_norm2 = 0;
                        reduce_scalar.run_with_barrier(instances);
                        scalar_buffer.get_data(new_scalar);
                        for (auto v : new_scalar) {
                            residual_norm2 += v;
                        }
                        if (residual_norm2 < cg_threshold) {
                            break;
                        }
                        abs_r_old = abs_r;
                        abs_r = 0.0f;
                        solve_for_z.run_with_barrier(instances);
                        reduce_scalar.run_with_barrier(instances);
                        scalar_buffer.get_data(new_scalar);
                        for (auto v : new_scalar) {
                            abs_r += v;
                        }

                        float beta = abs_r / abs_r_old;
//                        if (abs_r_old == 0) {
//                            beta = 0.0f;
//                        }
                        update_search_dir.update_uniform("beta", beta);
                        update_search_dir.run_with_barrier(instances);
                    }
                }
                float density_avg = 0;
                iteration = 0;
                predict_velocity.run_with_barrier(instances);

                //                update_dt();
                //                max_scalar.run_with_barrier(instances);
                //                scalar_buffer.get_data(new_scalar);
                //                float max_vel = 0;
                //                for (auto v : new_scalar) {
                //                    if (max_vel < v) {
                //                        max_vel = v;
                //                    }
                //                }
                //                sim_timer.update_dt_cfl(0.4, demo_consts.h, glm::sqrt(max_vel));
                //                
                // density error correction
                while ((density_avg - density_rest > density_eta || iteration < 2) && iteration < max_iterations) {
                    correct_density_error.run_with_barrier(instances);
                    reduce_scalar.run_with_barrier(instances);
                    scalar_buffer.get_data(new_scalar);
                    for (auto v : new_scalar) {
                        density_avg += v;
                    }
                    density_avg /= instances;
                    iteration++;
                }
                update_positions.run_with_barrier(instances);
                //sim_timer.advance();
                ips_counter.advance();
            }
            //sim_timer.advance_accumulator(fps_counter.delta_time());
        //}
        cam.update(curr_window, fps_counter.delta_time());
        mats.update(model, cam.get_view(), cam.get_projection());
        mvp.update_data(mats);
        particle_renderer.use();
        glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        particle_spheres.render(GL_TRIANGLES, static_cast<unsigned int>(instances));
        box_renderer.use();
        glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
        bounds_vao.render(GL_TRIANGLES);
        //gl_debug_logger.retrieve_log(std::cout);
        fps_counter.advance();
    };
    curr_window.run_loop(loop);
    return 0;
}
