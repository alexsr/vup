#version 450

layout (local_size_x = 128) in;

#include "sph_particle.inc.comp"

uniform float dt;
layout (std140, binding = 3) uniform demo_constants{
    SPH_demo_constants demo_consts;
};

layout (std430, binding = 4) buffer bound_buffer {
    vec4 bounds[36];
};

layout (std430, binding = 8) buffer particles {
    SPH_particle p[N];
};

vec3 calc_normal(vec4 o, vec4 a, vec4 b) {
    vec3 v1 = vec3(a - o);
    vec3 v2 = vec3(b - o);
    vec3 n = cross(v1, v2);
    return n/length(n);
}

float calc_wall_intersection(vec4 o, vec4 a, vec4 b, vec4 pos, float r) {
    vec3 v1 = vec3(a - o);
    vec3 v2 = vec3(b - o);
    vec3 n = cross(v1, v2);
    float d = dot(vec3(pos - o), n) / length(n);
    float inside_a = dot(v1, vec3(pos-o)) / length(v1);
    float inside_b = dot(v2, vec3(pos-o)) / length(v2);
    if (inside_a < length(v1) && inside_b < length(v2)) {
        return d-r;
    }
    return r;
}

vec3 reflect(vec3 d, vec3 n) {
    if (dot(d, n) < 0) {
        return d - 2.0f*dot(n, d)*n;
    }
    return d;
}

void collide_with_wall(float radius) {
    bool collision = false;
    uint id = gl_GlobalInvocationID.x;
    float d = calc_wall_intersection(bounds[1], bounds[0], bounds[2], p[id].pos, radius);
    if (d < 0.0f) {
        vec3 n = calc_normal(bounds[1], bounds[0], bounds[2]);
        p[id].pos.xyz -= n * d;
        p[id].vel.xyz = reflect(p[id].vel.xyz, n);
        collision = true;
    }
    d = calc_wall_intersection(bounds[7], bounds[6], bounds[8], p[id].pos, radius);
    if (d < 0.0f) {
        vec3 n = calc_normal(bounds[7], bounds[6], bounds[8]);
        p[id].pos.xyz -= n * d;
        p[id].vel.xyz = reflect(p[id].vel.xyz, n);
        collision = true;
    }
    d = calc_wall_intersection(bounds[13], bounds[12], bounds[14], p[id].pos, radius);
    if (d < 0.0f) {
        vec3 n = calc_normal(bounds[13], bounds[12], bounds[14]);
        p[id].pos.xyz -= n * d;
        p[id].vel.xyz = reflect(p[id].vel.xyz, n);
        collision = true;
    }
    d = calc_wall_intersection(bounds[19], bounds[18], bounds[20], p[id].pos, radius);
    if (d < 0.0f) {
        vec3 n = calc_normal(bounds[19], bounds[18], bounds[20]);
        p[id].pos.xyz -= n * d;
        p[id].vel.xyz = reflect(p[id].vel.xyz, n);
        collision = true;
    }
    d = calc_wall_intersection(bounds[25], bounds[24], bounds[26], p[id].pos, radius);
    if (d < 0.0f) {
        vec3 n = calc_normal(bounds[25], bounds[24], bounds[26]);
        p[id].pos.xyz -= n * d;
        p[id].vel.xyz = reflect(p[id].vel.xyz, n);
        collision = true;
    }
    d = calc_wall_intersection(bounds[31], bounds[30], bounds[32], p[id].pos, radius);
    if (d < 0.0f) {
        vec3 n = calc_normal(bounds[31], bounds[30], bounds[32]);
        p[id].pos.xyz -= n * d;
        p[id].vel.xyz = reflect(p[id].vel.xyz, n);
        collision = true;
    }
    if (collision) {
        p[id].vel *= 0.9f;
    }
}

void integrate_verlet(float dt) {
    uint id = gl_GlobalInvocationID.x;
    vec4 acc_extern = vec4(0.0f);
    acc_extern.y = -9.81f;
    vec4 a = vec4((p[id].force.xyz) / p[id].mass + acc_extern.xyz, 0.0f);
    p[id].pos += p[id].vel * dt + 0.5 * p[id].acc * dt * dt;
    p[id].vel += (p[id].acc + a) * 0.5 * dt;
    p[id].acc = a;
}

void integrate_euler(float dt) {
    uint id = gl_GlobalInvocationID.x;
    vec4 acc_extern = vec4(0.0f);
    acc_extern.y = -9.81f;
    vec4 a = vec4((p[id].force.xyz) / p[id].mass + acc_extern.xyz, 0.0f);
    p[id].vel += a * dt;
    p[id].pos += p[id].vel * dt;
}

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= N) {
        return;
    }
    int neighbor_amount = 50;
    int neighbors[50];
    int neighbor_counter = 0;
    for (int index = 0; index < N; index++) {
        if (index == id) {
            continue;
        }
        if (distance(p[id].pos.xyz, p[index].pos.xyz) <= demo_consts.h) {
                neighbors[neighbor_counter] = index;
                neighbor_counter++;
        }
        if (neighbor_counter >= neighbor_amount - 1) {
            break;
        }
    }

    barrier();

    float density_id = poly_six(demo_consts.h, 0.0);
    float pressure_id = 0;
    float k = 2000.0f;
    for (int i = 0; i < neighbor_counter; i++) {
        int j = neighbors[i];
        density_id += poly_six(demo_consts.h, distance(p[id].pos.xyz, p[j].pos.xyz));
    }

    p[id].density = p[id].mass * demo_consts.poly6 * density_id;
//    p[id].pressure = k * (density_id - p[id].rest_density);
    p[id].pressure = k * (pow(p[id].density / p[id].rest_density, 7.0f) - 1.0f);
    barrier();

    float visc_const = 0.02f;
    vec4 pressure_force = vec4(0.0f);
    vec4 visc_force = vec4(0.0f);
    for (int i = 0; i < neighbor_counter; i++) {
        int j = neighbors[i];
        vec4 pij = p[id].pos - p[j].pos;
        pressure_force += (p[id].pressure / (p[id].density * p[id].density)
                          + p[j].pressure / (p[j].density * p[j].density))
                          * spiky_gradient(demo_consts.h, pij);
        visc_force += (p[j].vel - p[id].vel) / p[j].density * visc(demo_consts.h, distance(p[id].pos.xyz, p[j].pos.xyz));
    }
    p[id].force = vec4(0.0f);
    p[id].force.xyz = (p[id].mass * demo_consts.spiky * (p[id].mass * pressure_force / p[id].density + visc_const * visc_force)).xyz;

    barrier();

    integrate_euler(dt);
    collide_with_wall(demo_consts.r);
}
