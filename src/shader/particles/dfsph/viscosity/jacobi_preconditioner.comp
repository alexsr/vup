#version 450

layout (local_size_x = 128) in;

#include "../particle_util.inc.comp"

#include "../ssbos.inc.comp"

#include "../boundary.inc.comp"

#include "../../../data_structures/compact_grid.inc.comp"

uniform float visc_const;

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= N) {
        return;
    }
    Particle p = particles[id];
    mat3 A = mat3(0);
    int i = int((p.pos.x - grid_params.grid_min.x) / grid_params.cell_size.x);
    int j = int((p.pos.y - grid_params.grid_min.y) / grid_params.cell_size.y);
    int k = int((p.pos.z - grid_params.grid_min.z) / grid_params.cell_size.z);
    int max_x = min(i + 2, grid_params.cell_count.x);
    int max_y = min(j + 2, grid_params.cell_count.y);
    int max_z = min(k + 2, grid_params.cell_count.z);
    for (int x = max(0, i - 1); x < max_x; x++) {
        int x_counter_offset = x * grid_params.cell_count.y * grid_params.cell_count.z;
        for (int y = max(0, j - 1); y < max_y; y++) {
            int y_counter_offset = y * grid_params.cell_count.z;
            for (int z = max(0, k - 1); z < max_z; z++) {
                int counter_id = x_counter_offset + y_counter_offset + z;
                if (counter_id >= CELL_COUNT) {
                    continue;
                }
                int grid_offset = 0;
                int boundary_grid_offset = 0;
                if (counter_id > 0) {
                    grid_offset = cell_counter[counter_id - 1];
                    boundary_grid_offset = boundary_cell_counter[counter_id - 1];
                }
                int n = cell_counter[counter_id] - grid_offset;
                for (int o = 0; o < n; o++) {
                    int other = grid[grid_offset + o];
                    if (id == other) {
                        continue;
                    }
                    Particle p_other = particles[other];
                    vec4 pij = vec4((p.pos - particles[other].pos).xyz, 0);
                    if (dot(pij, pij) < demo_consts.h2) {
                        vec3 grad = 10.0f * (p.viscosity + p_other.viscosity) / 2.0f
                                    * p_other.mass / p_other.density
                                    * demo_consts.kernel_grad * cubic_grad(demo_consts.h, pij).xyz
                                    / (dot(pij, pij) + 0.01 * demo_consts.h2);
                        A[0] += grad * pij.x;
                        A[1] += grad * pij.y;
                        A[2] += grad * pij.z;
                    }
                }
                n = boundary_cell_counter[counter_id] - boundary_grid_offset;
                for (int o = 0; o < n; o++) {
                    int other = boundary_grid[boundary_grid_offset + o];
                    float boundary_psi = boundaries[other].pos.w;
                    vec4 pij = vec4((p.pos - boundaries[other].pos).xyz, 0);
                    if (dot(pij, pij) < demo_consts.h2) {
                        vec3 grad = 10.0f
                                    * boundary_psi / p.density
                                    * demo_consts.kernel_grad * cubic_grad(demo_consts.h, pij).xyz
                                    / (dot(pij.xyz, pij.xyz) + 0.01 * demo_consts.h2);
                        A[0] += grad * pij.x;
                        A[1] += grad * pij.y;
                        A[2] += grad * pij.z;
                    }
                }
            }
        }
    }
    A = inverse(mat3(1.0) - demo_consts.dt / p.density * A);
    particles[id].precond[0] = vec4(A[0], 0);
    particles[id].precond[1] = vec4(A[1], 0);
    particles[id].precond[2] = vec4(A[2], 0);
}
