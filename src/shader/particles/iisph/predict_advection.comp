#version 450

layout (local_size_x = 128) in;

struct Fluid_particle {
    vec4 pos;
    vec4 vel;
    vec4 vel_adv;
    vec4 pressure_accel;
    vec4 dii;
    vec4 dij_pj_sum;
    float mass;
    float rest_density;
    float density;
    float density_adv;
    float pressure;
    float last_pressure;
    float aii;
    float aij_pj_sum;
};

struct SPH_demo_constants {
    float r;
    float h;
    float kernel;
    float kernel_grad;
    float visc;
};

float visc(float h, float r) {
    r = abs(r);
    if (0 <= r && r < h) {
        return h - r;
    }
    return 0.0f;
}

float cubic(float h, float r) {
    float res = 0.0;
    float q = r / h;
    if (q <= 1.0) {
        if (q <= 0.5) {
            float q2 = q * q;
            float q3 = q2 * q;
            res = (6.0*q3 - 6.0*q2 + 1.0);
        }
        else {
            res = (2.0*pow(1.0 - q, 3));
        }
    }
    return res;
}

float cubic(float h, vec4 v) {
    float r = length(v);
    float res = 0.0;
    float q = r / h;
    if (q <= 1.0) {
        if (q <= 0.5) {
            float q2 = q * q;
            float q3 = q2 * q;
            res = (6.0*q3 - 6.0*q2 + 1.0);
        }
        else {
            res = (2.0*pow(1.0 - q, 3));
        }
    }
    return res;
}

vec4 cubic_grad(float h, vec4 v) {
    vec4 res;
    float rl = length(v);
    float q = rl / h;
    if (q <= 1.0) {
        if (rl > 1.0e-6) {
            vec4 gradq = v * (1.0f / (rl*h));
            if (q <= 0.5) {
                res = q*(3.0f*q - 2.0f)*gradq;
            }
            else {
                float factor = 1.0 - q;
                res = (-factor * factor)*gradq;
            }
        }
    }
    else {
        res = vec4(0);
    }
    return res;
}

#include "/../viscosity.inc.comp"

layout (std430, binding = 0) buffer particles {
    Fluid_particle p[N];
};

layout (std430, binding = 1) buffer demo_constants{
    SPH_demo_constants demo_consts;
};

layout (std430, binding = 2) buffer neighborhood_data {
    int neighbor[NEIGHBOR_ARRAY_SIZE];
};

layout (std430, binding = 3) buffer neighborhood_count {
    int neighbor_counter[N];
};

uniform float dt;
uniform float visc_const;
uniform float tension_const;

void main() {
    uint id = gl_GlobalInvocationID.x;
    if (id >= N) {
        return;
    }
    float diam = 2.0f * demo_consts.r;
    float diam2 = diam * diam;
    p[id].dii = vec4(0.0);
    vec4 visc_force = vec4(0.0f);
    vec4 surface_tension_force = vec4(0.0f);
    float density2 = p[id].density * p[id].density;
    for (int i = 0; i < neighbor_counter[id]; i++) {
        int j = neighbor[id * NEIGHBOR_AMOUNT + i];
        vec4 pij = p[id].pos - p[j].pos;
        float r2 = dot(pij, pij);
        visc_force -= calc_xsph_visc_force(p[j].mass, p[id].vel, p[j].vel, p[j].density)
                      * demo_consts.visc * visc(demo_consts.h, length(pij));
        if (r2 > diam2) {
            surface_tension_force -= p[j].mass * pij * demo_consts.kernel * cubic(demo_consts.h, pij);
        }
        else {
            surface_tension_force -= p[j].mass * pij * demo_consts.kernel * cubic(demo_consts.h, diam);
        }
        p[id].dii -= p[j].mass / density2 * demo_consts.kernel_grad * cubic_grad(demo_consts.h, pij);
    }
    vec4 extern_force = vec4(0.0f);
    extern_force.y = -9.81f * p[id].mass;
    p[id].vel_adv = p[id].vel + dt * (visc_force * visc_const + surface_tension_force * tension_const + extern_force) / p[id].mass;
}