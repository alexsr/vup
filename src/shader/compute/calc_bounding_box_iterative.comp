#version 450

struct Bounds {
    float min_x;
    float max_x;
    float min_y;
    float max_y;
    float min_z;
    float max_z;
};

layout (std140, binding = 9) uniform mvp {
    mat4 model;
    mat4 view;
    mat4 projection;
};

uniform int max_index;
uniform int max_blocks;
layout (local_size_x = 1024) in;
shared Bounds shared_bounds[gl_WorkGroupSize.x];
layout (std430, binding = 5) buffer mesh {
    vec4 pos[];
};
layout (std430, binding = 4) buffer bounds_buffer {
    Bounds bounds[];
};
void main() {
    uint bid = gl_WorkGroupID.x;
    uint tid = gl_LocalInvocationIndex;
    uint id = gl_GlobalInvocationID.x;
    if (id < max_index) {
        vec4 p = model * pos[id];
        shared_bounds[tid].min_x = p.x;
        shared_bounds[tid].min_y = p.y;
        shared_bounds[tid].min_z = p.z;
        shared_bounds[tid].max_x = p.x;
        shared_bounds[tid].max_y = p.y;
        shared_bounds[tid].max_z = p.z;
    }
    else {
        shared_bounds[tid].max_x = -1.0f/0.0f;
        shared_bounds[tid].max_y = -1.0f/0.0f;
        shared_bounds[tid].max_z = -1.0f/0.0f;
        shared_bounds[tid].min_x = 1.0f/0.0f;
        shared_bounds[tid].min_y = 1.0f/0.0f;
        shared_bounds[tid].min_z = 1.0f/0.0f;
    }
	barrier();
    for (uint s = gl_WorkGroupSize.x / 2; s > 0; s>>=1) {
        if (tid < s) {
            if (shared_bounds[tid].min_x > shared_bounds[tid+s].min_x) {
                shared_bounds[tid].min_x = shared_bounds[tid+s].min_x;
            }
            if (shared_bounds[tid].min_y > shared_bounds[tid+s].min_y) {
                shared_bounds[tid].min_y = shared_bounds[tid+s].min_y;
            }
            if (shared_bounds[tid].min_z > shared_bounds[tid+s].min_z) {
                shared_bounds[tid].min_z = shared_bounds[tid+s].min_z;
            }
            if (shared_bounds[tid].max_x < shared_bounds[tid+s].max_x) {
                shared_bounds[tid].max_x = shared_bounds[tid+s].max_x;
            }
            if (shared_bounds[tid].max_y < shared_bounds[tid+s].max_y) {
                shared_bounds[tid].max_y = shared_bounds[tid+s].max_y;
            }
            if (shared_bounds[tid].max_z < shared_bounds[tid+s].max_z) {
                shared_bounds[tid].max_z = shared_bounds[tid+s].max_z;
            }
	    }
    }
    if (tid == 0 && max_blocks > bid) {
        bounds[bid].min_x = shared_bounds[0].min_x;
        bounds[bid].min_y = shared_bounds[0].min_y;
        bounds[bid].min_z = shared_bounds[0].min_z;
        bounds[bid].max_x = shared_bounds[0].max_x;
        bounds[bid].max_y = shared_bounds[0].max_y;
        bounds[bid].max_z = shared_bounds[0].max_z;
    }
}
